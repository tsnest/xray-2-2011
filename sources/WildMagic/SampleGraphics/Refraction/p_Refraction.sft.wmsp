// Software vertex shader generated by Wild Magic.
//
// var float     fReflectFactor $vin.COLOR
// var float2    kRefractVector $vin.TEXCOORD0
// var float2    kReflectVector $vin.TEXCOORD1
// var float4    kPixelColor    $vout.COLOR
// var sampler2D EnvMap0Sampler texunit 0
// var sampler2D EnvMap1Sampler texunit 1

#include "Wm4SoftRenderer.h"
#include "Wm4ColorRGBA.h"

namespace Wm4
{

ColorRGBA p_Refraction (const float*, SoftSampler** apkSampler,
    const float* afInPixel)
{
    // Get samplers.
    SoftSampler& rkEnvMap0Sampler = *apkSampler[0];
    SoftSampler& rkEnvMap1Sampler = *apkSampler[1];

    // Get input values.
    const float fReflectFactor = afInPixel[0];
    const float* afRefractVector = &afInPixel[1];
    const float* afReflectVector = &afInPixel[3];

    // *** program ***

    // We have already computed spherical coordinates for both the refraction
    // and reflection vectors in the vertex program.  So, just do the texture
    // look up and linearly interpolate between them based on the previously
    // computed reflection factor.
    ColorRGBA kRefractColor = rkEnvMap0Sampler(afRefractVector);
    ColorRGBA kReflectColor = rkEnvMap1Sampler(afReflectVector);
    ColorRGBA kPixelColor = Lerp(kRefractColor,kReflectColor,
        fReflectFactor);
    return kPixelColor;
}

WM4_IMPLEMENT_PPROGRAM(Refraction);
WM4_REGISTER_PPROGRAM(Refraction);

}
