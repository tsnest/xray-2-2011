// Software pixel shader generated by Wild Magic.
//
// var float2    kBaseTCoord        $vin.TEXCOORD0
// var float     fInterpolateFactor $vin.TEXCOORD1
// var float3    kWorldNormal       $vin.TEXCOORD2
// var float3    kEyeDirection      $vin.TEXCOORD3
// var float4    kPixelColor        $vout.COLOR
// var sampler2D BaseSampler        texunit 0
// var sampler1D GradientSampler    texunit 1

#include "Wm4SoftRenderer.h"
#include "Wm4ColorRGBA.h"
#include "Wm4Vector3.h"

namespace Wm4
{

ColorRGBA p_Iridescence (const float*, SoftSampler** apkSampler,
    const float* afInPixel)
{
    // Get samplers.
    SoftSampler& rkBaseSampler = *apkSampler[0];
    SoftSampler& rkGradientSampler = *apkSampler[1];

    // Get input values.
    const float* afBaseTCoord = &afInPixel[0];
    float fInterpolateFactor = afInPixel[2];
    const Vector3f& rkWorldNormal = *(const Vector3f*)&afInPixel[3];
    const Vector3f& rkEyeDirection = *(const Vector3f*)&afInPixel[6];

    // *** program ***

    // Calculate a Fresnel factor for a view-dependent lookup into a gradient
    // texture.  A different color/saturation occurs depending on what angle
    // you view at.
    float fFresnel = 1.0f + rkWorldNormal.Dot(rkEyeDirection);
    fFresnel = fFresnel*fFresnel;

    // The small perturbation of the Fresnel factor eliminates some spotting
    // where values are nearly zero.
    fFresnel += 1.0f/256.0f;
    if (fFresnel > 1.0f)
    {
        fFresnel = 1.0f;
    }

    ColorRGBA kBaseColor = rkBaseSampler(afBaseTCoord);
    ColorRGBA kGradientColor = rkGradientSampler(&fFresnel);
    ColorRGBA kPixelColor = Lerp(kBaseColor,kGradientColor,
        fInterpolateFactor);

    return kPixelColor;
}

WM4_IMPLEMENT_PPROGRAM(Iridescence);
WM4_REGISTER_PPROGRAM(Iridescence);

}
