// Software pixel shader generated by Wild Magic.
//
// var float2    kGroundTCoord  $vin.TEXCOORD0
// var float     kBlendTCoord   $vin.TEXCOORD1
// var float2    kCloudTCoord   $vin.TEXCOORD2
// var float2    kFlowDirection $vin.TEXCOORD3
// var float4    kPixelColor    $vout.COLOR
// var float     PowerFactor    c[1]
// var sampler2D GrassSampler   texunit 0
// var sampler2D StoneSampler   texunit 1
// var sampler1D BlendSampler   texunit 2
// var sampler2D CloudSampler   texunit 3

#include "Wm4SoftRenderer.h"
#include "Wm4ColorRGBA.h"
#include "Wm4Vector3.h"

namespace Wm4
{

ColorRGBA p_BlendedTerrain (const float* afRegister, SoftSampler** apkSampler,
    const float* afInPixel)
{
    // Get register values.
    float fPowerFactor = afRegister[0];

    // Get samplers.
    SoftSampler& rkGrassSampler = *apkSampler[0];
    SoftSampler& rkStoneSampler = *apkSampler[1];
    SoftSampler& rkBlendSampler = *apkSampler[2];
    SoftSampler& rkCloudSampler = *apkSampler[3];

    // Get input values.
    const float* afGroundTCoord = &afInPixel[0];
    const float* afBlendTCoord = &afInPixel[2];
    const float* afCloudTCoord = &afInPixel[3];
    const float* afFlowDirection = &afInPixel[5];

    // *** program ***

    ColorRGBA kGrassColor = rkGrassSampler(afGroundTCoord);
    ColorRGBA kStoneColor = rkStoneSampler(afGroundTCoord);
    ColorRGBA kBlendColor = rkBlendSampler(afBlendTCoord);

    float afOffsetCloudTCoord[2] =
    {
        afCloudTCoord[0] + afFlowDirection[0],
        afCloudTCoord[1] + afFlowDirection[1]
    };
    ColorRGBA kCloudColor = rkCloudSampler(afOffsetCloudTCoord);

    float fStoneWeight = Mathf::Pow(kBlendColor.R(),fPowerFactor);
    float fGrassWeight = 1.0f - fStoneWeight;
    ColorRGBA kPixelColor = kCloudColor*(fGrassWeight*kGrassColor +
        fStoneWeight*kStoneColor);

    return kPixelColor;
}

WM4_IMPLEMENT_PPROGRAM(BlendedTerrain);
WM4_REGISTER_PPROGRAM(BlendedTerrain);

}
