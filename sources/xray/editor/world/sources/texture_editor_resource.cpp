////////////////////////////////////////////////////////////////////////////
//	Created		: 10.02.2011
//	Author		: Andrew Kolomiets
//	Copyright (C) GSC Game World - 2011
////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "texture_editor_resource.h"

#include "texture_editor_source.h"
#include "texture_editor.h"

using xray::editor::wpf_controls::property_editors::attributes::combo_box_items_attribute;
using xray::editor::wpf_controls::property_editors::attributes::external_editor_attribute;
using xray::editor::wpf_controls::property_editors::attributes::external_editor_event_handler;

xray::render::texture_options::ETType get_texture_type_from_name(pcstr);

namespace xray {
namespace editor {

texture_editor_resource::texture_editor_resource( System::String^ resource_name, resource_changed_delegate^ changed_delegate, resource_load_delegate^ loaded_delegate ) 
{
	m_name					= resource_name;
	subscribe_on_changed	( changed_delegate );
	subscribe_on_loaded		( loaded_delegate );
	m_options_config		= NEW(configs::lua_config_ptr)();
	m_options_config_backup	= NEW(configs::lua_config_ptr)(configs::create_lua_config());
	init					( );

	m_load_query			= NEW(query_result_delegate)(gcnew query_result_delegate::Delegate( this, &texture_editor_resource::options_loaded), g_allocator);
	resources::query_resource(
					unmanaged_string(resource_name).c_str(),
					resources::texture_options_lua_class,
					boost::bind(&query_result_delegate::callback, m_load_query, _1),
					g_allocator
					);

}

void texture_editor_resource::init( )
{
	if(m_type_list.Count!=0)
		return;

	m_type_list.Add("Sky");
	m_type_list.Add("Bump");
	m_type_list.Add("Normal Map");
	m_type_list.Add("Terrain");
	m_type_list.Add("Terrain Bump");
	m_type_list.Add("Terrain Color");
	m_type_list.Add("2D");

	m_dimension_list.Add("Texture_1D");
	m_dimension_list.Add("Texture_2D");
	m_dimension_list.Add("Texture_3D");
	m_dimension_list.Add("Texture_cube");
	m_dimension_list.Add("Texture_2D_array");

	m_format_list.Add("Compressed RGB (DXT1)");
	m_format_list.Add("Compressed RGBA binary alpha (DXT1a)");
	m_format_list.Add("Compressed RGBA sharp alpha (DXT3)");
	m_format_list.Add("Compressed RGBA gradient alpha (DXT5)");
	m_format_list.Add("Uncompressed alpha channel only (A8)");
	m_format_list.Add("Normal map (DXT5n)");
	m_format_list.Add("Uncompressed RGBA");

	m_format_back_list.Add("DXT1");
	m_format_back_list.Add("DXT1a");
	m_format_back_list.Add("DXT3");
	m_format_back_list.Add("DXT5");
	m_format_back_list.Add("A8");
	m_format_back_list.Add("NORMAL_MAP");
	m_format_back_list.Add("UNCOMPRESSED");
}

#define texture_options_current_version "1.2"
void remove_value( configs::lua_config_value& t, pcstr value_name)
{
	if(t.value_exists(value_name))
		t.erase(value_name);
}

void texture_editor_resource::options_loaded( resources::queries_result& data )
{
	R_ASSERT				( data.is_successful() );
	m_load_query			= nullptr;
	(*m_options_config)		= static_cast_resource_ptr<configs::lua_config_ptr>(data[0].get_unmanaged_resource());
	loaded					= true;
	(*m_options_config_backup)->get_root().assign_lua_value( (*m_options_config)->get_root().copy() );

	pcstr ver = "0.0";

	if(opts().value_exists("ver"))
		ver = opts()["ver"];

	if(strings::less(ver, "1.2"))
	{
		configs::lua_config_value t = opts();
		remove_value( t, "width");
		remove_value( t, "height");
		remove_value( t, "bump_name");
		remove_value( t, "normal_name");
		remove_value( t, "color_name");
		remove_value( t, "detail_scale");
		remove_value( t, "tile");
		remove_value( t, "bump_mode");
		remove_value( t, "pack_mode");
		remove_value( t, "alpha_blend_mode");
		
		remove_value( t, "use_autogenerated_names");

		opts()["ver"]		= texture_options_current_version;
		properties_changed	( );
	}else
	{
//		LOG_INFO("no updates needed for %s", ver);
	}

	m_loaded_delegate		( this, true );
}

texture_editor_resource::~texture_editor_resource( )
{
	DELETE			( m_options_config );
	DELETE			( m_options_config_backup );
	if(m_load_query)
		m_load_query->m_rejected = true;
}

void texture_editor_resource::apply_changes( )
{
	if(loaded)
		(*m_options_config_backup)->get_root().assign_lua_value( (*m_options_config)->get_root().copy() );
}

void texture_editor_resource::reset_to_default( )
{
	if(loaded)
		(*m_options_config)->get_root().assign_lua_value( (*m_options_config_backup)->get_root().copy() );
}

void texture_editor_resource::save( )
{
	if(loaded)
		(*m_options_config)->save(configs::target_sources);
};

wpf_property_container^ texture_editor_resource::get_property_container( bool )
{
	wpf_property_container^ container	= gcnew wpf_property_container;

	unmanaged_string s(m_name);
	xray::render::texture_options::ETType type = get_texture_type_from_name(s.c_str());

	container->properties->add_from_obj( this, "name" );
	container->properties->add_from_obj( this, "type" );
	container->properties->add_from_obj( this, "width" );
	container->properties->add_from_obj( this, "height" );
	container->properties->add_from_obj( this, "dimension" )->dynamic_attributes->add( gcnew combo_box_items_attribute( %m_dimension_list ) );
	container->properties->add_from_obj( this, "format" )->dynamic_attributes->add( gcnew combo_box_items_attribute( %m_format_list ) );
	container->properties->add_from_obj( this, "srgb" );
	container->properties->add_from_obj( this, "high_quality" );
	
	switch (type)
	{
		//case xray::render::texture_options::bump:
		//	container->properties->add_from_obj( wrapper, "bump_mode" )->dynamic_attributes->add( gcnew combo_box_items_attribute( %wrapper->m_bump_mode_list ) );
		//break;

		case xray::render::texture_options::terrain:
//.			container->properties->add_from_obj( wrapper, "bump_name" )->dynamic_attributes->add( gcnew external_editor_attribute( gcnew external_editor_event_handler( this, &texture_document::external_editor_launch ) ) );
//.			container->properties->add_from_obj( wrapper, "color_name" )->dynamic_attributes->add( gcnew external_editor_attribute( gcnew external_editor_event_handler( this, &texture_document::external_editor_launch ) ) );
//.			container->properties->add_from_obj( wrapper, "tile" )->dynamic_attributes->add( gcnew combo_box_items_attribute( %wrapper->m_tile_list ) );
//.			container->properties["Part 2D/bump_name"]->category = "Terrain";
		break;

		case xray::render::texture_options::type_2d:
//.			container->properties->add_from_obj( wrapper, "alpha_blend" )->dynamic_attributes->add( gcnew combo_box_items_attribute( %wrapper->m_alpha_mode_list ) );
//.			container->properties->add_from_obj( wrapper, "pack_mode" )->dynamic_attributes->add( gcnew combo_box_items_attribute( %wrapper->m_pack_mode_list ) );
//.			container->properties->add_from_obj( wrapper, "bump_name" )->dynamic_attributes->add( gcnew external_editor_attribute( gcnew external_editor_event_handler( this, &texture_document::external_editor_launch ) ) );
//.			container->properties->add_from_obj( wrapper, "normal_name" )->dynamic_attributes->add( gcnew external_editor_attribute( gcnew external_editor_event_handler( this, &texture_document::external_editor_launch ) ) );
//.			container->properties->add_from_obj( wrapper, "use_autogenerated_names" );
		break;
	}

	return container;
}

System::String^ texture_editor_resource::name::get( )
{
	return m_name;
}

System::String^ texture_editor_resource::type::get( )
{
	unmanaged_string s(m_name);
	return m_type_list[get_texture_type_from_name(s.c_str())]->ToString();
}

System::String^ texture_editor_resource::dimension::get( )
{
	int dim = opts()["texture_dimension"];
	return m_dimension_list[dim]->ToString();
}

void texture_editor_resource::dimension::set( System::String^ value )
{
	int dim = m_dimension_list.IndexOf(value);
	opts()["texture_dimension"] = dim;
}

System::String^ texture_editor_resource::format::get( )
{
	return static_cast<System::String^>(m_format_list[m_format_back_list.IndexOf(gcnew System::String((pcstr)opts()["format"]))]);
}

void texture_editor_resource::format::set( System::String^ value )
{
	opts()["format"] = unmanaged_string(static_cast<System::String^>(m_format_back_list[m_format_list.IndexOf(value)])).c_str();
}

bool texture_editor_resource::has_mip_levels::get( )
{
	return (1==(int)opts()["has_mip_levels"]);
}

bool texture_editor_resource::srgb::get( )
{
	if (opts().value_exists("srgb"))
		return (1==(int)opts()["srgb"]);
	else
		return true;
}

void texture_editor_resource::srgb::set( bool value )
{
	opts()["srgb"] = value ? 1 : 0;
}

bool texture_editor_resource::high_quality::get( )
{
	if (opts().value_exists("high_quality"))
		return (1==(int)opts()["high_quality"]);
	else
		return false;
}

void texture_editor_resource::high_quality::set( bool value )
{
	opts()["high_quality"] = value ? 1 : 0;
}


void texture_editor_resource::has_mip_levels::set( bool value )
{
	opts()["has_mip_levels"] = value ? 1 : 0;
}


} // namespace editor
} // namespace xray
